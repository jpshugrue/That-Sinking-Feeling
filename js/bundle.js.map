{"version":3,"sources":["webpack:///webpack/bootstrap 168382e87ea804181269","webpack:///./js/main.js","webpack:///./js/game.js","webpack:///./js/board.js","webpack:///./js/player.js","webpack:///./js/tile.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;ACLD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AClBA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,+CAA+C;AAChH;AACA;AACA;AACA;AACA;AACA,uDAAuD,4CAA4C;AACnG;AACA;AACA;AACA,kCAAkC,0CAA0C;AAC5E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD,KAAK;AACL;AACA,iCAAiC,sBAAsB;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/KA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;;;;;ACjBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 168382e87ea804181269","import Game from \"./game\";\n\n$(() => {\n  const game = new Game();\n  game.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/main.js\n// module id = 0\n// module chunks = 0","import Board from './board';\n\nclass Game {\n\n  constructor() {\n    const canvas = document.getElementById('gameCanvas');\n    this.context = canvas.getContext('2d');\n    // this.context.translate(0, canvas.height);\n    // this.context.scale(1, -1);\n  }\n\n  start() {\n    const board = new Board(this.context);\n    board.main();\n  }\n\n}\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/game.js\n// module id = 1\n// module chunks = 0","import Player from './player';\nimport Tile from './tile';\n\nclass Board {\n\n  constructor(context) {\n    this.context = context;\n\n    this.TILE_SIZE = 10;\n    this.BOARD_DIM = 500;\n    this.MAX_HORIZONTAL_VEL = 20;\n    this.MAX_VERTICAL_VEL = -2;\n    this.FRICTION = 10;\n    this.GRAVITY = 3;\n\n    this.map = this.generateMap();\n    this.player = new Player([100,200], this.TILE_SIZE);\n\n    document.addEventListener('keydown', (event) => (this.keyPress(event, true)));\n    document.addEventListener('keyup', (event) => (this.keyPress(event, false)));\n\n    this.now = Date.now();\n\n    this.main = this.main.bind(this);\n    this.main();\n  }\n\n  main() {\n    let then = this.now;\n    this.now = Date.now();\n    let timeDiff = (this.now - then) / 1000.0;\n    this.update(timeDiff, this.player, this.map);\n    this.render();\n    window.requestAnimationFrame(this.main);\n  }\n\n  update(timeDiff, player, map) {\n    if (this.player.left) {\n      this.player.xVel = (this.player.xVel - (this.MAX_HORIZONTAL_VEL * timeDiff));\n      this.checkForCollisions(player, map);\n      if (Math.abs(this.player.xVel) > this.MAX_HORIZONTAL_VEL) { this.player.xVel = -(this.MAX_HORIZONTAL_VEL); }\n      this.player.x += this.player.xVel;\n    }\n    if (this.player.right) {\n      this.player.xVel = (this.player.xVel + (this.MAX_HORIZONTAL_VEL * timeDiff));\n      this.checkForCollisions(player, map);\n      if (this.player.xVel > this.MAX_HORIZONTAL_VEL) { this.player.xVel = this.MAX_HORIZONTAL_VEL; }\n      this.player.x += this.player.xVel;\n    }\n    if (this.player.jump) {\n     if (this.player.yVel === 0) { this.player.yVel = this.MAX_VERTICAL_VEL; }\n    }\n    this.checkForCollisions(player, map);\n    this.player.y += this.player.yVel;\n\n    this.handleFriction(timeDiff);\n    this.handleGravity(timeDiff);\n  }\n\n  getTilePos(x, y) {\n    const column = Math.floor(x / this.TILE_SIZE);\n    const row = Math.floor(y / this.TILE_SIZE);\n    return [row, column];\n  }\n\n  checkForCollisions(player, map) {\n    const nextX = player.x + player.xVel;\n    const nextY = player.y + player.yVel;\n    const tilePos = this.getTilePos(nextX, nextY);\n    const nextRow = tilePos[0];\n    const nextCol = tilePos[1];\n\n    if (player.xVel < 0) {\n      if ((player.y % this.TILE_SIZE < 1 && map[nextRow][nextCol].collides) ||\n        (player.y % this.TILE_SIZE >= 1 && (map[nextRow][nextCol].collides || map[nextRow+1][nextCol].collides))) {\n          player.xVel = 0;\n          player.x = map[nextRow][nextCol].x + this.TILE_SIZE;\n      }\n    } else if (player.xVel > 0) {\n      if ((player.y % this.TILE_SIZE < 1 && map[nextRow][nextCol+1].collides) ||\n        (player.y % this.TILE_SIZE >= 1 && (map[nextRow][nextCol+1].collides || map[nextRow+1][nextCol+1].collides))) {\n          player.xVel = 0;\n          player.x = map[nextRow][nextCol+1].x - this.TILE_SIZE;\n      }\n    }\n    if (player.yVel < 0) {\n      if ((player.x % this.TILE_SIZE < 1 && map[nextRow][nextCol].collides) ||\n        (player.x % this.TILE_SIZE >= 1 && (map[nextRow][nextCol].collides || map[nextRow][nextCol+1].collides))) {\n          player.yVel = 0;\n          player.y = map[nextRow][nextCol].y + this.TILE_SIZE;\n      }\n    } else if (player.yVel > 0) {\n      if ((player.x % this.TILE_SIZE < 1 && map[nextRow+1][nextCol].collides) ||\n        (player.x % this.TILE_SIZE >= 1 && (map[nextRow+1][nextCol].collides || map[nextRow+1][nextCol+1].collides))) {\n          player.yVel = 0;\n          player.y = map[nextRow+1][nextCol].y - this.TILE_SIZE;\n      }\n    }\n  }\n\n\n  handleFriction(timeDiff) {\n    if (this.player.xVel > 0) {\n      this.player.xVel -= this.FRICTION * timeDiff;\n      if (this.player.xVel < 0) { this.player.xVel = 0; }\n    } else if (this.player.xVel < 0) {\n      this.player.xVel += this.FRICTION * timeDiff;\n      if (this.player.xVel > 0) { this.player.xVel = 0; }\n    }\n  }\n\n  isStanding() {\n    const thisPos = this.getTilePos(this.player.x, this.player.y);\n    return this.map[thisPos[0]+1][thisPos[1]].collides;\n  }\n\n  handleGravity(timeDiff) {\n    if (this.isStanding()) {\n      this.player.yVel = 0;\n    } else {\n      this.player.yVel += this.GRAVITY * timeDiff;\n      if (this.player.yVel > 3) {\n        this.player.yVel = 3;\n      }\n    }\n  }\n\n  keyPress(event, pressed) {\n    switch(event.key) {\n      case \"ArrowLeft\":\n        this.player.left = pressed;\n        break;\n      case \"ArrowRight\":\n        this.player.right = pressed;\n        break;\n      case \" \":\n        event.preventDefault();\n        this.player.jump = pressed;\n    }\n  }\n\n  render() {\n    this.map.forEach((row, vertical) => {\n      row.forEach((tile, horizontal) => {\n        this.context.fillStyle = tile.color;\n        this.context.fillRect(horizontal * this.TILE_SIZE, vertical * this.TILE_SIZE, this.TILE_SIZE, this.TILE_SIZE);\n      });\n    });\n    this.context.fillStyle = \"yellow\";\n    this.context.fillRect(this.player.x, this.player.y, this.TILE_SIZE, this.TILE_SIZE);\n  }\n\n  generateMap() {\n    let map = [];\n    for(let i = 0; i < 50; i++) {\n      map.push([]);\n      for(let j = 0; j < 50; j++) {\n        map[i].push(new Tile([j*10, i*10], false, 10, \"blue\"));\n      }\n    }\n    map[22][9] = new Tile([90,220], true, 10, \"green\");\n    map[22][10] = new Tile([100,220], true, 10, \"green\");\n    map[22][11] = new Tile([110,220], true, 10, \"green\");\n    map[21][6] = new Tile([60,210], true, 10, \"green\");\n    map[21][7] = new Tile([70,210], true, 10, \"green\");\n    map[21][8] = new Tile([80,210], true, 10, \"green\");\n    map[20][16] = new Tile([160,200], true, 10, \"green\");\n    map[20][17] = new Tile([170,200], true, 10, \"green\");\n    map[20][18] = new Tile([180,200], true, 10, \"green\");\n    map[15][22] = new Tile([220,150], true, 10, \"green\");\n    map[15][23] = new Tile([230,150], true, 10, \"green\");\n    return map;\n  }\n}\n\nexport default Board;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/board.js\n// module id = 4\n// module chunks = 0","class Player {\n\n  constructor(startingPos, size) {\n    this.x = startingPos[0];\n    this.y = startingPos[1];\n    this.xVel = 0;\n    this.yVel = 0;\n    this.size = size;\n    this.left = false;\n    this.right = false;\n    this.jump = false;\n  }\n\n\n\n}\n\nexport default Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/player.js\n// module id = 5\n// module chunks = 0","class Tile {\n\n  constructor(position, collides, size, color) {\n    this.color = color;\n    this.size = size;\n    this.x = position[0];\n    this.y = position[1];\n    this.collides = collides;\n  }\n\n  inCollision(tile) {\n    return (this.x + this.size <= tile.x || this.x >= tile.x + tile.size\n      || this.y + this.size <= tile.y || this.y >= tile.y + tile.size);\n  }\n\n}\n\nexport default Tile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/tile.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}