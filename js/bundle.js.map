{"version":3,"sources":["webpack:///webpack/bootstrap 34935c3f493da6926004","webpack:///./js/main.js","webpack:///./js/game.js","webpack:///./js/player.js","webpack:///./js/map.js","webpack:///./js/tile.js","webpack:///./js/water.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACLD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,4DAA4D,0CAA0C;AACtG;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kDAAkD,uCAAuC;AACzF;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD,KAAK;AACL;AACA,iCAAiC,sBAAsB;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACrMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACnBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA,KAAK;AACL;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AChHA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AC3BA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 34935c3f493da6926004","import Game from \"./game\";\n\n$(() => {\n  const game = new Game();\n  game.main();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/main.js\n// module id = 0\n// module chunks = 0","import Player from './player';\nimport Map from './map';\nimport Water from './water';\n\nclass Game {\n\n  constructor() {\n    const canvas = document.getElementById('gameCanvas');\n    this.context = canvas.getContext('2d');\n\n    this.TILE_SIZE = 16;\n    this.BOARD_DIM = 608;\n    this.MAX_HORIZONTAL_VEL = 22;\n    this.MAX_JUMP_VEL = -8;\n    this.MAX_FALL_VEL = 32;\n    this.FRICTION = 16;\n    this.GRAVITY = 16;\n\n    this.gameOver = false;\n\n    this.map = new Map(this.BOARD_DIM, this.TILE_SIZE, this.context);\n    this.map.generateMap(this.BOARD_DIM, this.TILE_SIZE);\n    this.player = new Player([320,384], this.TILE_SIZE);\n\n    document.addEventListener('keydown', (event) => (this.keyPress(event, true)));\n    document.addEventListener('keyup', (event) => (this.keyPress(event, false)));\n\n    this.now = Date.now();\n\n    this.main = this.main.bind(this);\n\n    this.background = new Image(this.boardDim, this.boardDim);\n    this.background.src = 'images/sprites/bg_orig.gif';\n\n    this.water = new Water(this.TILE_SIZE, this.BOARD_DIM, this.context);\n  }\n\n  main() {\n    let then = this.now;\n    this.now = Date.now();\n    let timeDiff = (this.now - then) / 1000.0;\n    if (this.gameOver) {\n      this.endGame();\n    } else {\n      this.update(timeDiff, this.player, this.map);\n\n      this.render();\n    }\n\n    window.requestAnimationFrame(this.main);\n  }\n\n  render() {\n    this.context.clearRect(0, 0, this.BOARD_DIM, this.BOARD_DIM);\n    this.context.drawImage(this.background, 0, 0);\n    this.map.render(this.context);\n    this.player.render(this.context);\n    this.water.render();\n  }\n\n  endGame() {\n    this.context.font = \"30px Arial\";\n    this.context.fillText(\"Game Over\",200,200);\n  }\n\n  update(timeDiff, player, map) {\n    if (player.left) {\n      if (player.xVel > 0 ) { player.xVel = 0; }\n      player.xVel = (player.xVel - (this.MAX_HORIZONTAL_VEL * timeDiff));\n      if (Math.abs(player.xVel) > this.MAX_HORIZONTAL_VEL) { player.xVel = -(this.MAX_HORIZONTAL_VEL); }\n    }\n    if (player.right) {\n      if (player.xVel < 0 ) { player.xVel = 0; }\n      player.xVel = (player.xVel + (this.MAX_HORIZONTAL_VEL * timeDiff));\n      if (player.xVel > this.MAX_HORIZONTAL_VEL) { player.xVel = this.MAX_HORIZONTAL_VEL; }\n    }\n    if (player.jump) {\n      if (player.yVel === 0) { player.yVel = this.MAX_JUMP_VEL; }\n    }\n    this.checkForGameOver(player);\n    if (!this.gameOver) {\n      this.checkForCollisions(player, map);\n      if (player.left || player.right) {\n        player.x += player.xVel;\n      }\n      player.y += player.yVel;\n      this.handleFriction(timeDiff);\n      this.handleGravity(timeDiff, player, map);\n    }\n    if (this.player.y < this.BOARD_DIM / 2) {\n      this.map.nextPixel();\n      this.water.nextPixel();\n      this.player.y += 1;\n    }\n    this.water.update(timeDiff);\n  }\n\n  getTilePos(x, y) {\n    const column = Math.floor(x / this.TILE_SIZE);\n    const row = Math.floor(y / this.TILE_SIZE);\n    return [row + 1, column];\n  }\n\n  checkForGameOver(player) {\n    const nextY = player.y + player.yVel;\n    if (nextY > this.BOARD_DIM - this.TILE_SIZE || nextY > this.water.level) {\n      this.gameOver = true;\n    }\n  }\n\n  checkForCollisions(player, map) {\n    const nextX = player.x + player.xVel;\n    const nextY = player.y + player.yVel;\n    const nextPlayer = new Player([nextX, nextY], this.TILE_SIZE);\n    const tilePos = this.getTilePos(nextX, nextY - map.offSet);\n    let nextRow = tilePos[0];\n    let nextCol = tilePos[1];\n\n    if (nextRow < 0) {\n      nextRow = 0;\n      player.yVel = 0.01;\n      player.y = 0;\n    }\n    if (player.xVel < 0) {\n      if(map.tile(nextRow, nextCol).inCollision(nextPlayer) || map.tile(nextRow+1, nextCol).inCollision(nextPlayer)) {\n        // debugger\n        player.xVel = 0;\n        player.x = map.tile(nextRow, nextCol).x + this.TILE_SIZE;\n        nextCol += 1;\n      }\n    } else if (player.xVel > 0) {\n      if(map.tile(nextRow, nextCol+1).inCollision(nextPlayer) || map.tile(nextRow+1, nextCol+1).inCollision(nextPlayer)) {\n        player.xVel = 0;\n        player.x = map.tile(nextRow, nextCol+1).x - this.TILE_SIZE;\n      }\n    }\n    if (player.yVel < 0) {\n      if(map.tile(nextRow, nextCol).inCollision(nextPlayer) || map.tile(nextRow, nextCol+1).inCollision(nextPlayer)) {\n        player.yVel = 0;\n        player.y = map.tile(nextRow, nextCol).y + this.TILE_SIZE;\n      }\n    } else if (player.yVel > 0) {\n      if(map.tile(nextRow+1, nextCol).inCollision(nextPlayer) || map.tile(nextRow+1, nextCol+1).inCollision(nextPlayer)) {\n        player.yVel = 0;\n        player.y = map.tile(nextRow+1, nextCol).y - this.TILE_SIZE;\n      }\n    }\n  }\n\n  handleFriction(timeDiff) {\n    if (this.player.xVel > 0) {\n      this.player.xVel -= this.FRICTION * timeDiff;\n      if (this.player.xVel < 0) { this.player.xVel = 0; }\n    } else if (this.player.xVel < 0) {\n      this.player.xVel += this.FRICTION * timeDiff;\n      if (this.player.xVel > 0) { this.player.xVel = 0; }\n    }\n  }\n\n  isStanding(player, map) {\n    const tilePos = this.getTilePos(this.player.x, this.player.y - this.map.offSet);\n    return (this.map.tile(tilePos[0]+1, tilePos[1]).collides || this.map.tile(tilePos[0]+1, tilePos[1]+1).collides);\n  }\n\n  handleGravity(timeDiff, player, map) {\n    if (this.isStanding(player, map)) {\n      player.yVel = 0;\n    } else {\n      player.yVel += this.GRAVITY * timeDiff;\n      if (player.yVel > this.MAX_FALL_VEL) {\n        player.yVel = this.MAX_FALL_VEL;\n      }\n    }\n  }\n\n  keyPress(event, pressed) {\n    switch(event.key) {\n      case \"ArrowLeft\":\n        this.player.left = pressed;\n        break;\n      case \"ArrowRight\":\n        this.player.right = pressed;\n        break;\n      case \"ArrowUp\":\n        event.preventDefault();\n        break;\n      case \"ArrowDown\":\n        event.preventDefault();\n        break;\n      case \" \":\n        event.preventDefault();\n        this.player.jump = pressed;\n    }\n  }\n\n}\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/game.js\n// module id = 1\n// module chunks = 0","class Player {\n\n  constructor(startingPos, size) {\n    this.x = startingPos[0];\n    this.y = startingPos[1];\n    this.xVel = 0;\n    this.yVel = 0;\n    this.size = size;\n    this.left = false;\n    this.right = false;\n    this.jump = false;\n  }\n\n  render(context) {\n    context.fillStyle = \"white\";\n    context.fillRect(this.x, this.y, this.size, this.size);\n  }\n}\n\nexport default Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/player.js\n// module id = 2\n// module chunks = 0","import Tile from './tile';\n\nclass Map {\n\n  constructor(boardDim, tileSize, context) {\n    this.boardDim = boardDim;\n    this.tileSize = tileSize;\n    this.context = context;\n    this.map = [];\n    this.rowsWoPlatform = 0;\n    this.numTiles = this.boardDim / this.tileSize;\n    this.offSet = 0;\n    this.leftWallImg = new Image(this.tileSize, this.tileSize);\n    this.leftWallImg.src = 'images/sprites/left_wall.gif';\n    this.rightWallImg = new Image(this.tileSize, this.tileSize);\n    this.rightWallImg.src = 'images/sprites/right_wall.gif';\n    this.platformImg = new Image(this.tileSize, this.tileSize);\n    this.platformImg.src = 'images/sprites/platform.gif';\n  }\n\n  tile(row, col) {\n    return this.map[row][col];\n  }\n\n  nextRow() {\n    for(let idx = this.map.length - 1; idx >= 0; idx--) {\n      if (idx === 0) {\n        this.map[idx] = this.generateRow();\n        this.map[idx].forEach((tile) => {\n          tile.y = -this.tileSize;\n        });\n      } else {\n        this.map[idx] = this.map[idx - 1];\n      }\n    }\n  }\n\n  nextPixel() {\n    this.offSet += 1;\n    this.map.forEach((row) => {\n      row.forEach((tile) => {\n          tile.y += 1;\n      });\n    });\n    if (this.map[0][0].y === 0 ) {\n      this.offSet = 0;\n      this.nextRow();\n    }\n  }\n\n  generateRow() {\n    let newRow = [];\n    let platform, platformPos;\n    if (this.rowsWoPlatform > 4 || Math.random() < 0.2) {\n      platform = this.generatePlatform();\n      platformPos = Math.floor(Math.random() * (this.numTiles - platform.length));\n      if (platformPos < 0) { platformPos = 0; }\n      this.rowsWoPlatform = 0;\n    } else {\n      this.rowsWoPlatform += 1;\n    }\n    for(let i = 0; i < this.numTiles; i++) {\n      if (i === 0) {\n        newRow.push(new Tile([i * this.tileSize, 0], true, this.tileSize, this.leftWallImg));\n      } else if (i === this.numTiles - 1) {\n        newRow.push(new Tile([i * this.tileSize, 0], true, this.tileSize, this.rightWallImg));\n      } else {\n        newRow.push(new Tile([i * this.tileSize, 0], false, this.tileSize, \"blue\"));\n      }\n    }\n    if (platform) {\n      for(let i = 0; i < platform.length; i++) {\n        platform[i].x = this.tileSize * (platformPos + i);\n        newRow[platformPos + i] = platform[i];\n      }\n    }\n    return newRow;\n  }\n\n  generatePlatform() {\n    const length = Math.floor(Math.random() * (this.numTiles / 2 - 4)) + 3;\n    let platform = [];\n    for (let i = 0; i < length; i++) {\n      platform.push(new Tile([0, 0], true, this.tileSize, this.platformImg));\n    }\n    return platform;\n  }\n\n  render() {\n    this.map.forEach((row) => {\n      row.forEach((tile) => {\n        tile.render(this.context);\n      });\n    });\n  }\n\n  generateMap(boardDim, tileSize) {\n    this.map = [];\n    for(let i = 0; i <= this.numTiles; i++) {\n      this.map.push(this.generateRow());\n      this.map[i].forEach((tile) => {\n        tile.y = (i-1)*this.tileSize;\n      });\n    }\n    this.map[25][20] = new Tile([320,384], false, 16, \"blue\");\n    this.map[26][20] = new Tile([320,400], true, 16, this.platformImg);\n    // this.map[41][25] = new Tile([375,640], false, 16, \"blue\");\n    // this.map[42][25] = new Tile([375,656], true, 16, \"green\");\n  }\n\n}\n\nexport default Map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/map.js\n// module id = 3\n// module chunks = 0","class Tile {\n\n  constructor(position, collides, size, image) {\n    this.image = image;\n    this.size = size;\n    this.x = position[0];\n    this.y = position[1];\n    this.collides = collides;\n  }\n\n  render(context) {\n    if (this.collides) {\n      context.drawImage(this.image, this.x, this.y);\n      // UPDATE THIS\n      // context.fillStyle = this.color;\n      // context.fillRect(this.x, this.y, this.size, this.size);\n    }\n  }\n\n  inCollision(player) {\n    // debugger\n    return (this.collides && !(this.x >= player.x + player.size || this.x + this.size <= player.x\n      || this.y >= player.y + player.size || this.y + this.size <= player.y));\n  }\n\n}\n\nexport default Tile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/tile.js\n// module id = 4\n// module chunks = 0","class Water {\n\n  constructor(tileSize, boardDim, context) {\n    this.tileSize = tileSize;\n    this.boardDim = boardDim;\n    this.context = context;\n\n    this.waterImg1 = new Image(boardDim-this.tileSize, boardDim);\n    this.waterImg1.src = 'images/sprites/water1.png';\n\n    this.waterImg2 = new Image(boardDim-this.tileSize, boardDim);\n    this.waterImg2.src = 'images/sprites/water2.png';\n\n    this.waterImg = this.waterImg1;\n\n    this.level = boardDim - (tileSize * 3);\n    this.speed = 20;\n    this.animCounter = 0;\n  }\n\n  update(timeDiff) {\n    this.level -= timeDiff * this.speed;\n    this.animCounter += timeDiff;\n    if (this.animCounter > 1) {\n      this.animCounter = 0;\n      this.animate();\n    }\n  }\n\n  nextPixel() {\n    this.level += 1;\n  }\n\n  animate() {\n    console.log(\"gets here\");\n    if (this.waterImg === this.waterImg1) {\n      this.waterImg = this.waterImg2;\n    } else {\n      this.waterImg = this.waterImg1;\n    }\n  }\n\n  render() {\n    this.context.drawImage(this.waterImg, this.tileSize, this.level);\n  }\n\n}\n\nexport default Water;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/water.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}