{"version":3,"sources":["webpack:///webpack/bootstrap 00685b37fecf5f13ddc4","webpack:///./js/main.js","webpack:///./js/game.js","webpack:///./js/player.js","webpack:///./js/tile.js","webpack:///./js/map.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;ACLD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,4DAA4D,0CAA0C;AACtG;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kDAAkD,uCAAuC;AACzF;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD,KAAK;AACL;AACA,iCAAiC,sBAAsB;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACvLA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;ACxBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA,KAAK;AACL;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 00685b37fecf5f13ddc4","import Game from \"./game\";\n\n$(() => {\n  const game = new Game();\n  game.main();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/main.js\n// module id = 0\n// module chunks = 0","import Player from './player';\nimport Map from './map';\n\nclass Game {\n\n  constructor() {\n    const canvas = document.getElementById('gameCanvas');\n    this.context = canvas.getContext('2d');\n\n    this.TILE_SIZE = 10;\n    this.BOARD_DIM = 500;\n    this.MAX_HORIZONTAL_VEL = 14;\n    this.MAX_JUMP_VEL = -5;\n    this.MAX_FALL_VEL = 20;\n    this.FRICTION = 10;\n    this.GRAVITY = 10;\n\n    this.gameOver = false;\n\n    this.map = new Map(this.BOARD_DIM, this.TILE_SIZE, this.context);\n    this.map.generateMap(this.BOARD_DIM, this.TILE_SIZE);\n    // debugger\n    this.player = new Player([250,250], this.TILE_SIZE);\n\n    document.addEventListener('keydown', (event) => (this.keyPress(event, true)));\n    document.addEventListener('keyup', (event) => (this.keyPress(event, false)));\n\n    this.now = Date.now();\n\n    this.main = this.main.bind(this);\n  }\n\n  main() {\n    let then = this.now;\n    this.now = Date.now();\n    let timeDiff = (this.now - then) / 1000.0;\n    if (this.gameOver) {\n      this.endGame();\n    } else {\n      this.update(timeDiff, this.player, this.map);\n\n      this.context.clearRect(0, 0, this.BOARD_DIM, this.BOARD_DIM);\n      this.map.render(this.context);\n      this.player.render(this.context);\n    }\n\n    window.requestAnimationFrame(this.main);\n  }\n\n  endGame() {\n    this.context.font = \"30px Arial\";\n    this.context.fillText(\"Game Over\",200,200);\n  }\n\n  update(timeDiff, player, map) {\n    if (player.left) {\n      if (player.xVel > 0 ) { player.xVel = 0; }\n      player.xVel = (player.xVel - (this.MAX_HORIZONTAL_VEL * timeDiff));\n      if (Math.abs(player.xVel) > this.MAX_HORIZONTAL_VEL) { player.xVel = -(this.MAX_HORIZONTAL_VEL); }\n    }\n    if (player.right) {\n      if (player.xVel < 0 ) { player.xVel = 0; }\n      player.xVel = (player.xVel + (this.MAX_HORIZONTAL_VEL * timeDiff));\n      if (player.xVel > this.MAX_HORIZONTAL_VEL) { player.xVel = this.MAX_HORIZONTAL_VEL; }\n    }\n    if (player.jump) {\n      if (player.yVel === 0) { player.yVel = this.MAX_JUMP_VEL; }\n    }\n    this.checkForBoundaries(player);\n    if (!this.gameOver) {\n      this.checkForCollisions(player, map);\n      if (player.left || player.right) {\n        player.x += player.xVel;\n      }\n      player.y += player.yVel;\n      this.handleFriction(timeDiff);\n      this.handleGravity(timeDiff, player);\n    }\n  }\n\n  getTilePos(x, y) {\n    const column = Math.floor(x / this.TILE_SIZE);\n    const row = Math.floor(y / this.TILE_SIZE);\n    return [row, column];\n  }\n\n  checkForBoundaries(player) {\n    const nextY = player.y + player.yVel;\n    if (nextY > this.BOARD_DIM - this.TILE_SIZE) {\n      this.gameOver = true;\n    }\n  }\n\n  checkForCollisions(player, map) {\n    const nextX = player.x + player.xVel;\n    const nextY = player.y + player.yVel;\n    const tilePos = this.getTilePos(nextX, nextY);\n    let nextRow = tilePos[0];\n    let nextCol = tilePos[1];\n\n    if (nextRow < 0) {\n      nextRow = 0;\n      player.yVel = 0.01;\n      player.y = 0;\n    }\n    if (player.xVel < 0) {\n      if ((nextY % this.TILE_SIZE < 1 && map.tile(nextRow, nextCol).collides) ||\n        (nextY % this.TILE_SIZE >= 1 && (map.tile(nextRow, nextCol).collides || map.tile(nextRow+1, nextCol).collides))) {\n          player.xVel = 0;\n          player.x = map.tile(nextRow, nextCol).x + this.TILE_SIZE;\n          nextCol += 1;\n      }\n    } else if (player.xVel > 0) {\n      if ((nextY % this.TILE_SIZE < 1 && map.tile(nextRow, nextCol+1).collides) ||\n        (nextY % this.TILE_SIZE >= 1 && (map.tile(nextRow, nextCol+1).collides || map.tile(nextRow+1, nextCol+1).collides))) {\n          player.xVel = 0;\n          player.x = map.tile(nextRow, nextCol+1).x - this.TILE_SIZE;\n      }\n    }\n    if (player.yVel < 0) {\n      if ((player.x % this.TILE_SIZE < 1 && map.tile(nextRow, nextCol).collides) ||\n        (player.x % this.TILE_SIZE >= 1 && (map.tile(nextRow, nextCol).collides || map.tile(nextRow, nextCol+1).collides))) {\n          player.yVel = 0;\n          player.y = map.tile(nextRow, nextCol).y + this.TILE_SIZE;\n      }\n    } else if (player.yVel > 0) {\n      if ((player.x % this.TILE_SIZE < 1 && map.tile(nextRow+1, nextCol).collides) ||\n        (player.x % this.TILE_SIZE >= 1 && (map.tile(nextRow+1, nextCol).collides || map.tile(nextRow+1, nextCol+1).collides))) {\n          player.yVel = 0;\n          player.y = map.tile(nextRow+1, nextCol).y - this.TILE_SIZE;\n      }\n    }\n  }\n\n  handleFriction(timeDiff) {\n    if (this.player.xVel > 0) {\n      this.player.xVel -= this.FRICTION * timeDiff;\n      if (this.player.xVel < 0) { this.player.xVel = 0; }\n    } else if (this.player.xVel < 0) {\n      this.player.xVel += this.FRICTION * timeDiff;\n      if (this.player.xVel > 0) { this.player.xVel = 0; }\n    }\n  }\n\n  isStanding(player) {\n    const thisPos = this.getTilePos(this.player.x, this.player.y);\n    return ((player.x % this.TILE_SIZE < 1 && this.map.tile(thisPos[0]+1, thisPos[1]).collides) ||\n      (player.x % this.TILE_SIZE >= 1 && (this.map.tile(thisPos[0]+1, thisPos[1]).collides || this.map.tile(thisPos[0]+1, thisPos[1]+1).collides)));\n  }\n\n  handleGravity(timeDiff, player) {\n    if (this.isStanding(player)) {\n      player.yVel = 0;\n    } else {\n      player.yVel += this.GRAVITY * timeDiff;\n      if (player.yVel > this.MAX_FALL_VEL) {\n        player.yVel = this.MAX_FALL_VEL;\n      }\n    }\n  }\n\n  keyPress(event, pressed) {\n    switch(event.key) {\n      case \"ArrowLeft\":\n        this.player.left = pressed;\n        break;\n      case \"ArrowRight\":\n        this.player.right = pressed;\n        break;\n      case \"ArrowUp\":\n        event.preventDefault();\n        break;\n      case \"ArrowDown\":\n        event.preventDefault();\n        break;\n      case \" \":\n        event.preventDefault();\n        this.player.jump = pressed;\n    }\n  }\n\n}\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/game.js\n// module id = 1\n// module chunks = 0","class Player {\n\n  constructor(startingPos, size) {\n    this.x = startingPos[0];\n    this.y = startingPos[1];\n    this.xVel = 0;\n    this.yVel = 0;\n    this.size = size;\n    this.left = false;\n    this.right = false;\n    this.jump = false;\n  }\n\n  render(context) {\n    context.fillStyle = \"black\";\n    context.fillRect(this.x, this.y, this.size, this.size);\n  }\n}\n\nexport default Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/player.js\n// module id = 2\n// module chunks = 0","class Tile {\n\n  constructor(position, collides, size, color) {\n    this.color = color;\n    this.size = size;\n    this.x = position[0];\n    this.y = position[1];\n    this.collides = collides;\n  }\n\n  render(context) {\n    if (this.collides) {\n      context.fillStyle = this.color;\n      context.fillRect(this.x, this.y, this.size, this.size);\n    }\n  }\n\n  // inCollision(tile) {\n  //   return (this.x + this.size <= tile.x || this.x >= tile.x + tile.size\n  //     || this.y + this.size <= tile.y || this.y >= tile.y + tile.size);\n  // }\n\n}\n\nexport default Tile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/tile.js\n// module id = 3\n// module chunks = 0","import Tile from './tile';\n\nclass Map {\n\n  constructor(boardDim, tileSize, context) {\n    this.boardDim = boardDim;\n    this.tileSize = tileSize;\n    this.context = context;\n    this.map = [];\n    this.rowsWoPlatform = 0;\n    this.numTiles = this.boardDim / this.tileSize;\n  }\n\n  tile(row, col) {\n    return this.map[row][col];\n  }\n\n  nextRow() {\n    this.map.forEach((row, idx) => {\n      if (idx === this.map.length - 1) {\n        this.map[idx] = this.generateRow();\n      } else {\n        row.forEach((tile) => {\n          tile.y = tile.y + this.tileSize;\n        });\n        this.map[idx] = this.map[idx + 1];\n      }\n    });\n  }\n\n  generateRow() {\n    let newRow = [];\n    let platform, platformPos;\n    if (this.rowsWoPlatform > 4 || Math.random() < 0.2) {\n      platform = this.generatePlatform();\n      platformPos = Math.floor(Math.random() * (this.numTiles - platform.length));\n      // This way may result in left biased placement of platforms\n      if (platformPos < 0) { platformPos = 0; }\n      this.rowsWoPlatform = 0;\n    } else {\n      this.rowsWoPlatform += 1;\n    }\n    for(let i = 0; i < this.numTiles; i++) {\n      newRow.push(new Tile([i * this.tileSize, 0], false, this.tileSize, \"blue\"));\n    }\n    if (platform) {\n      for(let i = 0; i < platform.length; i++) {\n        platform[i].x = this.tileSize * (platformPos + i);\n        newRow[platformPos + i] = platform[i];\n      }\n    }\n    return newRow;\n  }\n\n  generatePlatform() {\n    const length = Math.floor(Math.random() * (this.numTiles / 2 - 2)) + 3;\n    let platform = [];\n    for (let i = 0; i < length; i++) {\n      platform.push(new Tile([0, 0], true, this.tileSize, \"green\"));\n    }\n    return platform;\n  }\n\n  render() {\n    this.map.forEach((row) => {\n      row.forEach((tile) => {\n        tile.render(this.context);\n      });\n    });\n  }\n\n  generateMap(boardDim, tileSize) {\n    this.map = [];\n    for(let i = 0; i < this.numTiles; i++) {\n      this.map.push(this.generateRow());\n      this.map[i].forEach((tile) => {\n        tile.y = i*this.tileSize;\n      });\n    }\n    // const numTiles = this.boardDim / this.tileSize;\n    // this.map = [];\n    // for(let i = 0; i < numTiles; i++) {\n    //   this.map.push([]);\n    //   for(let j = 0; j < numTiles; j++) {\n    //     if (j === 0 || j === numTiles-1) {\n    //       this.map[i].push(new Tile([j*this.tileSize, i*this.tileSize], true, this.tileSize, \"red\"));\n    //     } else {\n    //       this.map[i].push(new Tile([j*this.tileSize, i*this.tileSize], false, this.tileSize, \"blue\"));\n    //     }\n    //   }\n    // }\n    this.map[25][25] = new Tile([250,250], false, 10, \"blue\");\n    this.map[26][25] = new Tile([250,260], true, 10, \"green\");\n    // this.map[19][26] = new Tile([260,190], true, 10, \"green\");\n    // this.map[26][5] = new Tile([50,260], true, 10, \"green\");\n    // this.map[22][10] = new Tile([100,220], true, 10, \"green\");\n    // this.map[22][11] = new Tile([110,220], true, 10, \"green\");\n    // this.map[21][6] = new Tile([60,210], true, 10, \"green\");\n    // this.map[21][7] = new Tile([70,210], true, 10, \"green\");\n    // this.map[21][8] = new Tile([80,210], true, 10, \"green\");\n    // this.map[20][16] = new Tile([160,200], true, 10, \"green\");\n    // this.map[20][17] = new Tile([170,200], true, 10, \"green\");\n    // this.map[20][18] = new Tile([180,200], true, 10, \"green\");\n    // this.map[15][22] = new Tile([220,150], true, 10, \"green\");\n    // this.map[15][23] = new Tile([230,150], true, 10, \"green\");\n  }\n\n}\n\nexport default Map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/map.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}